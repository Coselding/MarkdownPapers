options {
    LOOKAHEAD = 1;
    STATIC = false;
    UNICODE_INPUT = true;

    MULTI = true;
    /*
    NODE_EXTENDS = "org.tautua.markdownpapers.Node";
    */
    NODE_PREFIX = "";
    NODE_DEFAULT_VOID = true;
    NODE_USES_PARSER = false;

    DEBUG_PARSER = true;
    DEBUG_TOKEN_MANAGER = false;
    DEBUG_LOOKAHEAD = false;
}

PARSER_BEGIN(Parser)
package org.tautua.markdownpapers.grammar;

import org.tautua.markdownpapers.grammar.util.*;

public class Parser {
    private static final String EMPTY_STRING = "";
    private static final String QUOTE = '"' + "";

    private Stack<Node> stack = new DequeStack<Node>();
    private int currentQuoteLevel = 0;
    int ident;
    int delta;

    public Object parse() throws ParseException {
        jj_input_stream.setTabSize(4);
        Document();
        return jjtree.rootNode();
    }

    char getEscapedChar(Token t) {
        return t.image.charAt(1);
    }

    String getValue(Token t) {
        if (t.kind == CODE_SPAN && t.image.startsWith("``")) {
            return getValue(t, 2);            
        } else if (t.kind == TEXT) {
            return t.image;
        }
        return getValue(t, 1);
    }

    String getValue(Token t, int markLength) {
        return t.image.substring(markLength, t.image.length() - markLength);
    }

    String getTabWhitespace(Token prev, Token tab) {
        int x = (4 - ((prev == null ? 1 : prev.endColumn + 1) % 4)) + 1;
        switch(x) {
            case 1:
                return " ";
            case 2:
                return "  ";
            case 3:
                return "   ";
            default:
                return "    ";
        }
    }

    boolean ParagraphLookahead() {
        if (getToken(1).kind != EOL) {
            return false;
        }

        int i = 2;
        int quoteLevel = 0;
        Token t;

        do {
            t = getToken(i++);
            if (t.kind == GT) {
                quoteLevel++;
            } else if (t.kind == EOL) {
                quoteLevel = 0;
            }
        } while(t.oneOfKind(EOL, SPACE, TAB, GT));

        if (t.oneOfKind(PLUS, MINUS, ASTERISK, NUMBERING, EOF)) {
            return false;
        }

        if (currentQuoteLevel == quoteLevel && stack.size() > 0 && stack.peek() instanceof Item
            && ((Item)stack.peek()).getIndentation() < t.beginColumn) {
            return true;
        }

        return false;
    }

    boolean LineLookahead() {
        if (getToken(1).kind != EOL) {
            return false;
        }

        int i = 2;
        int quoteLevel = 0;
        Token t;

        do {
            t = getToken(i++);
            if(t.kind == GT) {
                quoteLevel++;
            }
        } while (t.oneOfKind(SPACE, TAB, GT));

        if (t.oneOfKind(EOL, EOF)) {
            return false;
        }

        if (stack.peek() instanceof Item && t.oneOfKind(PLUS, MINUS, ASTERISK, NUMBERING)) {
            return false;
        }

        if (currentQuoteLevel < quoteLevel) {
            return false;
        }

        return true;
    }

    boolean CodeLineLookahead() {
        if (getToken(1).kind != EOL) {
            return false;
        }

        int i = 2;
        int quoteLevel = 0;
        int _indent = 0;
        Token t;
        
        do {
            t = getToken(i++);
            if(t.kind == GT) {
                quoteLevel++;
                _indent = 0;
            } else if(t.kind == SPACE) {
                _indent++;
            } else if(t.kind == TAB) {
                _indent += 4;
            }
        } while (t.oneOfKind(SPACE, TAB, GT));

        if (t.oneOfKind(EOL, EOF)) {
            return true;
        }

        if (currentQuoteLevel >= quoteLevel && _indent >= 4) {
            return true;
        }

        return false;
    }

    boolean QuotedElementLookahead() {
        int level = 0;
        int i = 1;
        Token t = getToken(i);

        if (t.kind != EOL) {
            return false;
        }

        do {
            t = getToken(++i);
            if (t.kind == GT) {
                level++;
            }
        } while (t.oneOfKind(SPACE, TAB, GT));

        if (t.oneOfKind(EOL, EOF)) {
            return true;
        }

        if (currentQuoteLevel <= level) {
            return true;
        }

        return false;
    }

    boolean ItemLookahead() {
        if (getToken(1).kind != EOL) {
            return false;
        }

        List list = (List)stack.peek();
        Token t;
        int i = 2;
        int quoteLevel = 0;
        int _indent = 0;
        do {
            t = getToken(i++);
            if (t.kind == GT) {
                quoteLevel++;
            }
        } while (t.oneOfKind(EOL, SPACE, TAB, GT));

        if (t.oneOfKind(PLUS, MINUS, ASTERISK, NUMBERING)
            && list.getIndentation() == t.beginColumn) {
            return true;
        }

        return false;
    }

    boolean LooseLookahead() {
        if (getToken(1).kind != EOL) {
            return false;
        }

        int i = 2;
        Token t;
        boolean newline = false;
        do {
            t = getToken(i++);
            if (t.kind == EOL) {
                newline = true;
            }
        } while(t.oneOfKind(SPACE, TAB, EOL));

        Item item = (Item)stack.peek();

        return newline && t.oneOfKind(PLUS, MINUS, ASTERISK, NUMBERING) && item.getIndentation() == t.beginColumn;
    }

    boolean ListLookahead() {
        if (getToken(1).kind != EOL) {
            return false;
        }

        int quoteLevel = 0;
        int _indent = 0;
        int i = 2;
        Token t;
        do {
            t = getToken(i++);
            if (t.kind == GT) {
                quoteLevel++;
            } else if (t.kind == SPACE) {
                _indent++;
            } else if (t.kind == TAB) {
                _indent += 4;
            }
        } while (t.oneOfKind(SPACE, TAB, GT));

        if (t.oneOfKind(PLUS, MINUS, ASTERISK, NUMBERING)
            && _indent > ident) {
            return true;
        }
        
        return false;
    }

    boolean follows(int... args) {
        for(int i = 0; i < args.length; i++) {
            if (args[i] != getToken(i + 1).kind) {
                return false;
            }
        }
        return true;
    }
}
PARSER_END(Parser)

TOKEN_MGR_DECLS : {
    boolean expectBlockEnd;

    public int getLexicalState() {
        return curLexState;
    }

    void HandleEOL() {
        if (curLexState != TEXT_FOLLOWS && curLexState != LI_FOLLOWS) {
            SwitchTo(DEFAULT);
        } else if (expectBlockEnd) {
            expectBlockEnd = false;
            SwitchTo(DEFAULT);
        } else {
            expectBlockEnd = true;
        }
    }

    void HandleContent() {
        if (curLexState == DEFAULT) {
            SwitchTo(TEXT_FOLLOWS);
        }
        expectBlockEnd = false;
    }

}

<*>
TOKEN : {
    < SPACE : " " >
    | < TAB : "\t" >
    | < EOL : "\r" | "\n" | "\r\n" > { HandleEOL(); }
}

<DEFAULT, LI_FOLLOWS>
TOKEN : {
    < PLUS : "+" > : LI_FOLLOWS
    | < MINUS : "-" > : LI_FOLLOWS
    | < ASTERISK : "*" > : LI_FOLLOWS
    | < NUMBERING : ( ["0"-"9"] )+ "." > : LI_FOLLOWS
}

<DEFAULT, TEXT_FOLLOWS, LI_FOLLOWS>
TOKEN : {
    < UNDERSCORE_RULER : "_" ( (" "){0,2} )? "_"  ( ( (" "){0,2} )? "_" )+ >
    | < MINUS_RULER : "-" ( (" "){0,2} )? "-" ( ( (" "){0,2} )? "-" )+ >
    | < ASTERISK_RULER : "*" ( (" "){0,2} )? "*" ( ( (" "){0,2} )? "*" )+ >
}

/* PUNCTUATION */
<DEFAULT, HEADER_FOLLOWS, TEXT_FOLLOWS, LI_FOLLOWS>
TOKEN : {
    < AMPERSAND : "&" > { HandleContent(); }
    | < EXCLAMATION : "!" >
    | < HASH : "#" > : HEADER_FOLLOWS
    | < GT : ">" >
    | < LT : "<" > { HandleContent(); }
    | < LPAREN : "(" > { HandleContent(); }
    | < RPAREN : ")" > { HandleContent(); }
    | < LBRACKET : "[" > { HandleContent(); }
    | < RBRACKET : "]" > { HandleContent(); }
    | < COLON : ":" > { HandleContent(); }
    | < SLASH : "/" > { HandleContent(); }
    | < BACKSLASH : "\\" > { HandleContent(); }
    | < EQ : "=" > { HandleContent(); }
    | < OP_COMMENT : "<!--" > { HandleContent(); }
    | < CL_COMMENT : "-->" > { HandleContent(); }
}

<DEFAULT, HEADER_FOLLOWS, TEXT_FOLLOWS, LI_FOLLOWS>
TOKEN : {
    < ESCAPED_CHAR : "\\" ["{", "}", "[", "]", "(", ")"
                        , "\\", "`", "_", ">", "#", ".", "!"
                        , "+", "-", "*"] > { HandleContent(); }
    | < QUOTED_TEXT : "\"" ( ~["\"", "\r", "\n"] )+ "\""
                    | "'" ( ~["'", "\r", "\n"] )+ "'" > { HandleContent(); }
    | < CODE_SPAN : "`" ( ~["`"] )+ "`" | "`" "`" ( ~["'"] )+ "`" "`" > { HandleContent(); }
    | < EMPHASIS_ITALIC : "*" <EMP_A> ( ~["*"] )+ <EMP_A> "*"
                    | "_" <EMP_U> ( ~["_"] )+ <EMP_U> "_"> { HandleContent(); }
    | < EMPHASIS_BOLD : "**" <EMP_A> ( ~["*"] )+ <EMP_A> "**"
                    | "__" <EMP_U> ( ~["_"] )+ <EMP_U> "__"> { HandleContent(); }
    | < EMPHASIS_ITALIC_BOLD : "***" <EMP_A> ( ~["*"] )+ <EMP_A> "***"
                    | "___" <EMP_U> ( ~["_"] )+ <EMP_U> "___"> { HandleContent(); }
    | < CHAR_ENTITY_REF : "&" ( ["a"-"z", "A"-"Z"] )+ ";" > { HandleContent(); }
    | < NUMERIC_CHAR_REF : "&" ( ( ["0"-"9"] ){1,4} | "x" ( ["0"-"9", "a"-"f", "A"-"F"] ){1,4} ) ";" > { HandleContent(); }
    | < TEXT : ( ~["=", "#", "&", ":", "<", ">", "(", ")", "[", "]", " ", "\\", "/", "\t", "\r", "\n"] )+ > { HandleContent(); }
    | < #EMP_A : ~["*", " ", "\t", "\r", "\n"] >
    | < #EMP_U : ~["_", " ", "\t", "\r", "\n"] >
}

void Document() #Document : {} {
    (
    <EOL>
    | Element() ( LOOKAHEAD(2) <EOL> Element() )*
    )*
    <EOF>
}

void Element() : {} {
    LOOKAHEAD( LinkRef() ) DocumentElement() | BlockElement() 
}

void DocumentElement() : {} {
    LinkRef()
}

void BlockElement() : {} {
    Header()
    | LOOKAHEAD( EmptyLine() ) Whitespace()
    | LOOKAHEAD( ( InsignificantWhitespace() )? ( <UNDERSCORE_RULER> | <MINUS_RULER> | <ASTERISK_RULER> ) ( <EOL> | <EOF> ) ) Ruler()
    | LOOKAHEAD( CodeLine() ) Code()
    | LOOKAHEAD( QuotePrefix() ) Quote()
    | LOOKAHEAD( ( <SPACE> | <TAB> )* ( <PLUS> | <MINUS> | <ASTERISK> | <NUMBERING> ) ) List()
    | LOOKAHEAD( Comment() ) Comment()
    | Paragraph()
}

void Whitespace() : {} {
    ( <SPACE> | <TAB> )+
}

void InsignificantWhitespace() : {} {
    <SPACE> ( <SPACE> ( <SPACE> )? )?
}

void EmptyLine() : {} {
    ( Whitespace() )? ( <EOL> | <EOF> )
}

void Header() #Header : {
    int level = 1;
} {
    "#" ( "#" { level++; } ( "#" { level++; } ( "#" { level++; } ( "#" { level++; } ( "#" { level++; } )? )? )? )? )?
    { jjtThis.setLevel(level); }
    Line()
}

void Ruler() #Ruler : {} {
    ( InsignificantWhitespace() )? ( <UNDERSCORE_RULER> | <MINUS_RULER> | <ASTERISK_RULER> )
}

void Quote() #Quote : {
    stack.push(jjtThis);
    currentQuoteLevel++;
} {
    QuotePrefix() BlockElement()
    ( LOOKAHEAD( {QuotedElementLookahead()} ) <EOL>
        (
            LOOKAHEAD( QuotePrefix() ) QuotePrefix() ( BlockElement() )?
            | Whitespace()
        )?
    )*
    {
    currentQuoteLevel--;
    stack.pop();
    }
}

void QuotePrefix() : {} {
    ( <SPACE> | <TAB> )* <GT> 
}

void Code() #Code : {} {
    CodeLine()
    ( LOOKAHEAD( {CodeLineLookahead()} ) <EOL>
        (
            LOOKAHEAD( ( <GT> | <SPACE> | <TAB> )* ( <EOL>|<EOF> ) )
            ( <GT> | <SPACE> | <TAB> )* #Line
            | LOOKAHEAD( CodeLine() ) CodeLine()
            | ( LOOKAHEAD( QuotePrefix() ) QuotePrefix() )+ <SPACE> CodeLine()
        )
    )*
}

void CodeLine() #Line : {} {
    ( <SPACE> <SPACE> <SPACE> <SPACE> | <TAB> ) CodeText()
}

void CodeText() #CodeText : {
    Token current;
    Token prev = null;
} {
    (
        (
            (
                current = <SPACE>
                | current = <ESCAPED_CHAR>
                | current = <EXCLAMATION>
                | current = <NUMERIC_CHAR_REF>
                | current = <CHAR_ENTITY_REF>
                | current = <TEXT>
                | current = <HASH>
                | current = <AMPERSAND>
                | current = <LPAREN>
                | current = <RPAREN>
                | current = <LBRACKET>
                | current = <RBRACKET>
                | current = <COLON>
                | current = <SLASH>
                | current = <BACKSLASH>
                | current = <GT>
                | current = <LT>
                | current = <MINUS>
                | current = <PLUS>
                | current = <ASTERISK>
                | current = <UNDERSCORE_RULER>
                | current = <MINUS_RULER>
                | current = <ASTERISK_RULER>
                | current = <EQ>
                | current = <QUOTED_TEXT>
            ) { jjtThis.append(current.image); }
            | current = <TAB> { jjtThis.append(getTabWhitespace(prev, current)); }
        ) { prev = current; }
    )*
}


void LinkRef() #LinkRef : {
    String n, u = null;
    Token t = null;
} {
    ( <SPACE> ( <SPACE> ( <SPACE> )? )? )?
    "[" n = refname() "]" { jjtThis.setId(n); }
    ( <SPACE> )? ":"
    ( Whitespace() )?
    u = url()
    ( Whitespace() )?
    ( t = <QUOTED_TEXT> )? { jjtThis.setResource(new Resource(u, t == null ? null : getValue(t))); }
}

void List() #List : {
    stack.push(jjtThis);
    int oldIdent = ident;
    int oldDelta = delta;
} {
    (
        <SPACE> { ident++; }
        | <TAB> { ident += 4; }
        | <GT> { ident = 0; }
    )*          { delta = ident - oldIdent; }
    Item()
    (
        LOOKAHEAD( {ItemLookahead()} ) <EOL>
        ( <SPACE> | <TAB> | <GT> )* ( Item() )?
    )*

    {
        ident = oldIdent;
        delta = oldDelta;
        stack.pop();
    }
}

void Item() #Item : {
    stack.push(jjtThis);
    Token t;
} {
    ( t = <PLUS> | t = <MINUS> | t = <ASTERISK> | t = <NUMBERING> { jjtThis.makeOrdered(); } ( <SPACE> | <TAB> )) { jjtThis.setIndentation(t.beginColumn); }
    Paragraph() ( LOOKAHEAD( {ParagraphLookahead()} ) <EOL> ( LOOKAHEAD( EmptyLine() ) ( Whitespace() )? <EOL> )* Paragraph() )*
    ( LOOKAHEAD( {ListLookahead()} ) <EOL> List() )?
    ( LOOKAHEAD( {LooseLookahead()} ) <EOL> ( Whitespace() )? { jjtThis.makeLoose(); } )?

    {
        Item item = (Item)stack.pop();
        List list = (List)stack.peek();
        if (list.getIndentation() == 0) {
            list.setIndentation(item.getIndentation());
        } 
    }
}

void Loose(Token t) : {
    Token nt;
} {
     <EOL> ( ( Whitespace() )? <EOL> )+ ( Whitespace() )? ( nt = <PLUS> | nt = <MINUS> | nt = <ASTERISK> | nt = <NUMBERING> )
     { if (nt.beginColumn < t.beginColumn) throw new ParseException("not at same level."); }
}

void Paragraph() #Paragraph : {} {
    Line()
    ( LOOKAHEAD( {LineLookahead()} ) <EOL> ( <SPACE> | <TAB> | <GT> )* Line() )*
}

void Line() #Line : {} {
    (
        CharRef()
        | CodeSpan()
        | Emphasis()
        | LOOKAHEAD( InlineURL() ) InlineURL()
        | LOOKAHEAD( Tag() ) Tag()
        | LOOKAHEAD( Image() ) Image()
        | LOOKAHEAD( Link() ) Link()
        | Text()
    )+
}

void Text() #Text : {
    Token t;
} {
        t = <ESCAPED_CHAR> { jjtThis.append(getEscapedChar(t)); }
        | (
            t = <TEXT>
            | t = <HASH>
            | t = <SPACE>
            | t = <TAB>
            | t = <AMPERSAND>
            | t = <LPAREN>
            | t = <RPAREN>
            | t = <LBRACKET>
            | t = <RBRACKET>
            | t = <COLON>
            | t = <SLASH>
            | t = <BACKSLASH>
            | t = <GT>
            | t = <LT>
            | t = <MINUS>
            | t = <PLUS>
            | t = <NUMBERING>
            | t = <ASTERISK>
            | t = <UNDERSCORE_RULER>
            | t = <MINUS_RULER>
            | t = <ASTERISK_RULER>
            | t = <EQ>
            | t = <QUOTED_TEXT>
        ) { jjtThis.append(t.image); }
}

void CharRef() #CharRef : {
    Token t;
} {
    ( t = <NUMERIC_CHAR_REF> | t = <CHAR_ENTITY_REF> ) { jjtThis.setValue(t.image); }
}

void CodeSpan() #CodeSpan : {
    Token t;
} {
    t = <CODE_SPAN> { jjtThis.setText(getValue(t)); }
}

void Emphasis() #Emphasis : {
    Token t;
    int markLength = 1;
} {
    (
        t = <EMPHASIS_ITALIC>
        | t = <EMPHASIS_BOLD> { markLength = 2; jjtThis.makeBold(); }
        | t = <EMPHASIS_ITALIC_BOLD> { markLength = 3; jjtThis.makeItalicAndBold(); }
    ) { jjtThis.setText(getValue(t, markLength)); }
}

void Comment() #Comment : {
    StringBuilder buff = new StringBuilder();
    Token t;
} {
    <OP_COMMENT>
    (
        (
        t = <TEXT>
        | t = <SPACE>
        | t = <TAB>
        | t = <AMPERSAND>
        | t = <EXCLAMATION>
        | t = <HASH>
        | t = <GT>
        | t = <LT>
        | t = <LPAREN>
        | t = <RPAREN>
        | t = <LBRACKET>
        | t = <RBRACKET>
        | t = <COLON>
        | t = <SLASH>
        | t = <BACKSLASH>
        | t = <EQ>
        | t = <MINUS_RULER>
        | t = <UNDERSCORE_RULER>
        | t = <ASTERISK_RULER>
        | t = <EOL>
        ) { buff.append(t.image); }
    )*
    { jjtThis.setText(buff.toString()); }
    <CL_COMMENT>
}

void InlineURL() #InlineUrl : {
    Token t;
    StringBuilder buff = new StringBuilder();
} {
    <LT>
    t = <TEXT> { buff.append(t.image); }
    ":" { buff.append(":"); }
    ( "/" { buff.append("/"); } )*
    t = <TEXT> { buff.append(t.image); }
    (
        t = <TEXT> { buff.append(t.image); }
        | "/" { buff.append("/"); }
        | "&" { buff.append("&"); }
        | "=" { buff.append("="); }
    )*
    <GT>
    { jjtThis.setUrl(buff.toString()); }
}

void Link() #Link : {
    String text, refid = "", url = null;
    Resource resource = null;
    Token title = null;
} {
    "["
    text = LinkText() { jjtThis.setText(text); }
    "]"
    (
        ( <SPACE> )? ( <EOL> )?
        "["
            ( refid = refname() )?
            { jjtThis.makeReferenced(refid); }
        "]"
        |
        "("
            (
                url = url()
                (
                    ( <SPACE> | <TAB> )+
                    title = <QUOTED_TEXT>
                )?
                { resource = new Resource(url, title != null ? getValue(title) : null); }
                ( <SPACE> )*
            )?
            { jjtThis.makeInline(resource); }
        ")"
    )?
}

void Image() #Image : {
    String text, refid, url;
    Token title = null;
} {
    "!" "["
    text = refname() { jjtThis.setText(text); }
    "]"
    (
        ( <SPACE> )?
        "["
        refid = refname() { jjtThis.setRefId(refid); }
        "]"
        |
        "("
            (
                url = url()
                (
                    ( <SPACE> )+
                    title = <QUOTED_TEXT>
                )?
                { jjtThis.setResource(new Resource(url, title != null ? getValue(title) : null)); }
            )?
            ( <SPACE> )*
        ")"
    )?
}

void Tag() : {
    Token t, a, v;
    java.util.List<TagAttr> attributes = new java.util.ArrayList<TagAttr>();
} {
    (
    LOOKAHEAD(2)
    "<" "/"  t = <TEXT> <GT> #CloseTag { ((CloseTag)jjtree.peekNode()).setName(t.image);}
    |
    <LT> t = <TEXT>
    ( ( <SPACE> )+ a = <TEXT> "=" v = <QUOTED_TEXT> { attributes.add(new TagAttr(a.image, getValue(v))); } )*
    ( "/" ">" #EmptyTag { EmptyTag emptytag = (EmptyTag)jjtree.peekNode(); emptytag.setName(t.image); emptytag.setAttributes(attributes); }
    | <GT> #OpenTag { OpenTag opentag = (OpenTag)jjtree.peekNode(); opentag.setName(t.image); opentag.setAttributes(attributes); })
    )
}

String LinkText() : {
    Token t;
    String text;
    StringBuilder buff = new StringBuilder();
} {
    (
        (
            (
            t = <TEXT>
            | t = <SPACE>
            | t = <TAB>
            | t = <AMPERSAND>
            | t = <LPAREN>
            | t = <RPAREN>
            | t = <COLON>
            | t = <SLASH>
            | t = <BACKSLASH>
            | t = <GT>
            | t = <LT>
            | t = <EQ>
            ) { buff.append(t.image); }
        )+
        | <LBRACKET> text = LinkText() <RBRACKET> { buff.append("[").append(text).append("]"); }
    )+

    { return buff.toString(); }
}

String refname() : {
    Token t;
    StringBuilder buff = new StringBuilder();
} {
    (
        (
        t = <TEXT>
        | t = <SPACE>
        | t = <TAB>
        | t = <AMPERSAND>
        | t = <LPAREN>
        | t = <RPAREN>
        | t = <LBRACKET>
        | t = <COLON>
        | t = <SLASH>
        | t = <BACKSLASH>
        | t = <GT>
        | t = <LT>
        | t = <EQ>
        ) { buff.append(t.image); }
    )+
    { return buff.toString(); }
}

String url() : {
    Token t;
    StringBuilder buff = new StringBuilder();
} {
     (
     (
        <LT>
        (
            (
            t = <TEXT>
            | t = <AMPERSAND>
            | t = <LPAREN>
            | t = <LBRACKET>
            | t = <RBRACKET>
            | t = <COLON>
            | t = <SLASH>
            | t = <BACKSLASH>
            | t = <HASH>
            | t = <EQ>
            ) { buff.append(t.image); }
        ) +
        <GT>
    )
    | (
        (
        t = <TEXT>
        | t = <AMPERSAND>
        | t = <LPAREN>
        | t = <LBRACKET>
        | t = <RBRACKET>
        | t = <COLON>
        | t = <SLASH>
        | t = <BACKSLASH>
        | t = <HASH>
        | t = <EQ>
        ) { buff.append(t.image); }
    )+
    )
    { return buff.toString(); }
}